declare const _default: "\"use strict\";\nlet canvas = undefined;\nlet opts = undefined;\nlet plotData = undefined;\nlet plotDataFiltered = undefined;\nonmessage = function (evt) {\n    if (evt.data.canvas) {\n        canvas = evt.data.canvas;\n        drawDebounced();\n    }\n    if (evt.data.opts) {\n        opts = evt.data.opts;\n        drawDebounced();\n    }\n    if (evt.data.plotData) {\n        plotData = evt.data.plotData;\n        drawDebounced();\n    }\n};\nfunction debounce(f, msec) {\n    let scheduled = false;\n    return () => {\n        if (scheduled)\n            return;\n        scheduled = true;\n        setTimeout(() => {\n            scheduled = false;\n            f();\n        }, msec);\n    };\n}\nlet drawCode = 0;\nasync function draw() {\n    if (!canvas)\n        return;\n    if (!opts)\n        return;\n    if (!plotData)\n        return;\n    const { margins, canvasWidth, canvasHeight, visibleStartTimeSec, visibleEndTimeSec, hoveredUnitId, selectedUnitIds } = opts;\n    // this is important because main thread no longer has control of canvas (it seems)\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    const canvasContext = canvas.getContext(\"2d\");\n    if (!canvasContext)\n        return;\n    drawCode += 1;\n    const thisDrawCode = drawCode;\n    const numUnits = plotData.plots.length;\n    const unitIndexToY = (unitIndex) => (canvasHeight - margins.bottom - ((unitIndex + 0.5) - 0) / (numUnits - 0) * (canvasHeight - margins.top - margins.bottom));\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const pass of (plotData ? [1, 2] : [1])) {\n        if (thisDrawCode !== drawCode)\n            return;\n        const timer = Date.now();\n        if ((pass === 2) || (!plotDataFiltered)) {\n            plotDataFiltered = filterPlotData(plotData);\n        }\n        const tToX = (t) => (margins.left + (t - visibleStartTimeSec) / (visibleEndTimeSec - visibleStartTimeSec) * (canvasWidth - margins.left - margins.right));\n        const pixelPlots = plotData.plots.map((plot, i) => {\n            return {\n                y: unitIndexToY(i),\n                x: plot.spikeTimesSec.map(t => (tToX(t))),\n                unitId: plot.unitId,\n                color: plot.color,\n                hovered: plot.unitId === hoveredUnitId,\n                selected: selectedUnitIds.includes(plot.unitId)\n            };\n        });\n        paintPanel(canvasContext, pixelPlots);\n        // the wait time is equal to the render time\n        const elapsed = Date.now() - timer;\n        await sleepMsec(elapsed);\n    }\n}\nconst drawDebounced = debounce(draw, 10);\nconst paintPanel = (context, pixelPlots) => {\n    if (!opts)\n        return;\n    const { margins, canvasWidth, canvasHeight } = opts;\n    context.clearRect(0, 0, canvasWidth, canvasHeight);\n    const pixelsPerUnit = canvasHeight / pixelPlots.length;\n    // do this before clipping\n    for (const pass of [1, 2, 3]) {\n        pixelPlots.forEach(pPlot => {\n            if (((pass === 1) && (pixelsPerUnit >= 10)) || ((pass === 2) && (pPlot.selected)) || ((pass === 3) && (pPlot.hovered))) {\n                context.fillStyle = pass === 1 ? pPlot.color : pass === 2 ? 'black' : pPlot.color;\n                context.textAlign = 'right';\n                context.textBaseline = 'middle';\n                context.font = `${pass > 1 ? 'bold ' : ''}12px Arial`;\n                context.fillText(pPlot.unitId + '', margins.left - 4, pPlot.y);\n                if ((pass === 3) || ((pass === 2) && pPlot.hovered)) {\n                    context.textAlign = 'left';\n                    context.textBaseline = 'middle';\n                    context.font = `${pass > 1 ? 'bold ' : ''}12px Arial`;\n                    context.fillText(pPlot.unitId + '', canvasWidth - margins.right + 4, pPlot.y);\n                }\n            }\n        });\n    }\n    context.save();\n    context.beginPath();\n    context.rect(margins.left, margins.top, canvasWidth - margins.left - margins.right, canvasHeight - margins.top - margins.bottom);\n    context.clip();\n    for (const pass of [1, 2]) {\n        pixelPlots.forEach(pPlot => {\n            if ((pass === 2) && (pPlot.hovered)) {\n                context.strokeStyle = 'yellow';\n                context.lineWidth = 3;\n                context.beginPath();\n                context.moveTo(0, pPlot.y);\n                context.lineTo(canvasWidth, pPlot.y);\n                context.stroke();\n                context.strokeStyle = 'gray';\n                context.lineWidth = 1;\n                context.beginPath();\n                context.moveTo(0, pPlot.y);\n                context.lineTo(canvasWidth, pPlot.y);\n                context.stroke();\n            }\n            if ((pass === 1) && (pPlot.selected)) {\n                context.strokeStyle = 'lightblue';\n                context.lineWidth = 3;\n                context.beginPath();\n                context.moveTo(0, pPlot.y);\n                context.lineTo(canvasWidth, pPlot.y);\n                context.stroke();\n            }\n        });\n    }\n    pixelPlots.forEach(pPlot => {\n        context.strokeStyle = pPlot.color;\n        context.lineWidth = 3;\n        context.beginPath();\n        pPlot.x.forEach(x => {\n            context.moveTo(x - 2, pPlot.y);\n            context.lineTo(x + 2, pPlot.y);\n        });\n        context.stroke();\n    });\n    context.restore();\n};\nconst filterPlotData = (plotData) => {\n    if (!opts)\n        return undefined;\n    const { visibleStartTimeSec, visibleEndTimeSec } = opts;\n    if ((visibleStartTimeSec === undefined) || (visibleEndTimeSec === undefined)) {\n        return undefined;\n    }\n    const newPlots = plotData.plots.map(plot => ({\n        ...plot,\n        spikeTimesSec: plot.spikeTimesSec.filter(t => (visibleStartTimeSec <= t) && (t <= visibleEndTimeSec))\n    }));\n    return {\n        ...plotData,\n        plots: newPlots\n    };\n};\nfunction sleepMsec(msec) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, msec);\n    });\n}\n";
export default _default;
