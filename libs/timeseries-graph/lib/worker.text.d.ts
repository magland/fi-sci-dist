declare const _default: "\"use strict\";\nlet canvas = undefined;\nlet opts = undefined;\nlet resolvedSeries = undefined;\nlet plotSeries = undefined;\n// let annotation: TimeseriesAnnotationFileData | undefined = undefined\nonmessage = function (evt) {\n    if (evt.data.canvas) {\n        canvas = evt.data.canvas;\n        drawDebounced();\n    }\n    if (evt.data.opts) {\n        opts = evt.data.opts;\n        drawDebounced();\n    }\n    if (evt.data.resolvedSeries) {\n        resolvedSeries = evt.data.resolvedSeries;\n        drawDebounced();\n    }\n    // if (evt.data.annotation) {\n    //     annotation = evt.data.annotation\n    //     drawDebounced()\n    // }\n};\nfunction debounce(f, msec) {\n    let scheduled = false;\n    return () => {\n        if (scheduled)\n            return;\n        scheduled = true;\n        setTimeout(() => {\n            scheduled = false;\n            f();\n        }, msec);\n    };\n}\nlet drawCode = 0;\nasync function draw() {\n    if (!canvas)\n        return;\n    if (!opts)\n        return;\n    if (!resolvedSeries)\n        return;\n    const { margins, canvasWidth, canvasHeight, visibleStartTimeSec, visibleEndTimeSec, minValue, maxValue } = opts;\n    // this is important because main thread no longer has control of canvas (it seems)\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    const canvasContext = canvas.getContext(\"2d\");\n    if (!canvasContext)\n        return;\n    drawCode += 1;\n    const thisDrawCode = drawCode;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const pass of (plotSeries ? [1, 2] : [1])) {\n        if (thisDrawCode !== drawCode)\n            return;\n        const timer = Date.now();\n        if ((pass === 2) || (!plotSeries)) {\n            plotSeries = computePlotSeries(resolvedSeries);\n        }\n        const coordToPixel = (p) => {\n            return {\n                x: margins.left + (p.x - visibleStartTimeSec) / (visibleEndTimeSec - visibleStartTimeSec) * (canvasWidth - margins.left - margins.right),\n                y: canvasHeight - margins.bottom - (p.y - minValue) / (maxValue - minValue) * (canvasHeight - margins.top - margins.bottom)\n            };\n        };\n        const pixelZero = coordToPixel({ x: 0, y: 0 }).y;\n        const pixelData = plotSeries.map((s, i) => {\n            return {\n                dimensionIndex: i,\n                dimensionLabel: `${i}`,\n                pixelTimes: s.times.map(t => coordToPixel({ x: t, y: 0 }).x),\n                pixelValues: s.values.map(y => coordToPixel({ x: 0, y }).y),\n                type: s.type,\n                attributes: s.attributes\n            };\n        });\n        const panelProps = {\n            pixelZero: pixelZero,\n            dimensions: pixelData\n        };\n        paintPanel(canvasContext, panelProps);\n        // the wait time is equal to the render time\n        const elapsed = Date.now() - timer;\n        await sleepMsec(elapsed);\n    }\n    // if (annotation) {\n    //     await drawAnnotation({\n    //         canvasContext,\n    //         canvasWidth,\n    //         canvasHeight,\n    //         visibleStartTimeSec,\n    //         visibleEndTimeSec,\n    //         margins,\n    //         annotation\n    //     })\n    // }\n}\nconst drawDebounced = debounce(draw, 10);\nconst paintLegend = (context) => {\n    if (!opts)\n        return;\n    if (opts.hideLegend)\n        return;\n    if (!resolvedSeries)\n        return;\n    const { legendOpts, margins, canvasWidth } = opts;\n    const seriesToInclude = resolvedSeries.filter(s => (s.title));\n    if (seriesToInclude.length === 0)\n        return;\n    const { location } = legendOpts;\n    const entryHeight = 18;\n    const entryFontSize = 12;\n    const symbolWidth = 50;\n    const legendWidth = 200;\n    const margin = 10;\n    const legendHeight = 20 + seriesToInclude.length * entryHeight;\n    const R = location === 'northwest' ? { x: margins.left + 20, y: margins.top + 20, w: legendWidth, h: legendHeight } :\n        location === 'northeast' ? { x: canvasWidth - margins.right - legendWidth - 20, y: margins.top + 20, w: legendWidth, h: legendHeight } : undefined;\n    if (!R)\n        return; //unexpected\n    context.fillStyle = 'white';\n    context.strokeStyle = 'gray';\n    context.lineWidth = 1.5;\n    context.fillRect(R.x, R.y, R.w, R.h);\n    context.strokeRect(R.x, R.y, R.w, R.h);\n    seriesToInclude.forEach((s, i) => {\n        const y0 = R.y + margin + i * entryHeight;\n        const symbolRect = { x: R.x + margin, y: y0, w: symbolWidth, h: entryHeight };\n        const titleRect = { x: R.x + margin + symbolWidth + margin, y: y0, w: legendWidth - margin - margin - symbolWidth - margin, h: entryHeight };\n        const title = s.title || 'untitled';\n        context.fillStyle = 'black';\n        context.font = `${entryFontSize}px Arial`;\n        context.fillText(title, titleRect.x, titleRect.y + titleRect.h / 2 + entryFontSize / 2);\n        if (s.type === 'line') {\n            applyLineAttributes(context, s.attributes);\n            context.beginPath();\n            context.moveTo(symbolRect.x, symbolRect.y + symbolRect.h / 2);\n            context.lineTo(symbolRect.x + symbolRect.w, symbolRect.y + symbolRect.h / 2);\n            context.stroke();\n            context.setLineDash([]);\n        }\n        else if (s.type === 'marker') {\n            applyMarkerAttributes(context, s.attributes);\n            const radius = entryHeight * 0.3;\n            const shape = s.attributes['shape'] ?? 'circle';\n            const center = { x: symbolRect.x + symbolRect.w / 2, y: symbolRect.y + symbolRect.h / 2 };\n            if (shape === 'circle') {\n                context.beginPath();\n                context.ellipse(center.x, center.y, radius, radius, 0, 0, 2 * Math.PI);\n                context.fill();\n            }\n            else if (shape === 'square') {\n                context.fillRect(center.x - radius, center.y - radius, radius * 2, radius * 2);\n            }\n        }\n    });\n};\nconst paintPanel = (context, props) => {\n    if (!opts)\n        return;\n    const { margins, canvasWidth, canvasHeight } = opts;\n    context.clearRect(0, 0, canvasWidth, canvasHeight);\n    context.save();\n    context.beginPath();\n    context.rect(margins.left, margins.top, canvasWidth - margins.left - margins.right, canvasHeight - margins.top - margins.bottom);\n    context.clip();\n    // don't display dashed zero line (Eric's request)\n    // context.strokeStyle = 'black'\n    // context.setLineDash([5, 15]);\n    // context.lineWidth = 1\n    // context.beginPath()\n    // context.moveTo(0, props.pixelZero)\n    // context.lineTo(panelWidth, props.pixelZero)\n    // context.stroke()\n    // context.setLineDash([]);\n    // eslint-disable-next-line react/prop-types\n    props.dimensions.forEach(dim => {\n        if (dim.type === 'line') {\n            applyLineAttributes(context, dim.attributes);\n            context.beginPath();\n            dim.pixelTimes.forEach((x, ii) => {\n                const y = dim.pixelValues[ii];\n                ii === 0 ? context.moveTo(x, y) : context.lineTo(x, y);\n            });\n            context.stroke();\n            context.setLineDash([]);\n        }\n        else if (dim.type === 'marker') {\n            applyMarkerAttributes(context, dim.attributes);\n            const radius = dim.attributes['radius'] ?? 2;\n            const shape = dim.attributes['shape'] ?? 'circle';\n            if (typeof radius !== 'number')\n                throw Error('Unexpected type of radius');\n            if (typeof shape !== 'string')\n                throw Error('Unexpected type of shape');\n            if (shape === 'circle') {\n                dim.pixelTimes.forEach((t, ii) => {\n                    context.beginPath();\n                    context.ellipse(t, dim.pixelValues[ii], radius, radius, 0, 0, 2 * Math.PI);\n                    context.fill();\n                });\n            }\n            else if (shape === 'square') {\n                dim.pixelTimes.forEach((t, ii) => {\n                    context.fillRect(t - radius, dim.pixelValues[ii] - radius, radius * 2, radius * 2);\n                });\n            }\n        }\n    });\n    paintLegend(context);\n    context.restore();\n};\nconst computePlotSeries = (resolvedSeries) => {\n    const plotSeries = [];\n    if (!opts)\n        return plotSeries;\n    const { visibleStartTimeSec, visibleEndTimeSec } = opts;\n    if ((visibleStartTimeSec === undefined) || (visibleEndTimeSec === undefined)) {\n        return plotSeries;\n    }\n    resolvedSeries.forEach(rs => {\n        const tt = rs.t;\n        const yy = rs.y;\n        let filteredTimeIndices = tt.flatMap((t, ii) => (visibleStartTimeSec <= t) && (t <= visibleEndTimeSec) ? ii : []);\n        // need to prepend an index before and append an index after so that lines get rendered properly\n        if ((filteredTimeIndices[0] || 0) > 0) {\n            filteredTimeIndices = [filteredTimeIndices[0] - 1, ...filteredTimeIndices];\n        }\n        if ((filteredTimeIndices[filteredTimeIndices.length - 1] || tt.length) < tt.length - 1) {\n            filteredTimeIndices.push(filteredTimeIndices[filteredTimeIndices.length - 1] + 1);\n        }\n        ////////////////////////////////////////////////////////////////////////////////\n        const filteredTimes = filteredTimeIndices.map(i => tt[i]);\n        const filteredValues = filteredTimeIndices.map(index => yy[index]);\n        plotSeries.push({\n            type: rs.type,\n            times: filteredTimes,\n            values: filteredValues,\n            attributes: rs.attributes\n        });\n    });\n    return plotSeries;\n};\nconst applyLineAttributes = (context, attributes) => {\n    const strokeStyle = attributes['color'] ?? 'black';\n    const lineWidth = attributes['width'] ?? 1.1; // 1.1 hack--but fixes the 'disappearing lines' issue\n    const dash = attributes['dash'] ?? undefined;\n    if (typeof strokeStyle === 'string') {\n        context.strokeStyle = strokeStyle;\n    }\n    if (typeof lineWidth === 'number') {\n        context.lineWidth = lineWidth;\n    }\n    if ((dash) && (typeof dash === 'object')) {\n        context.setLineDash(dash);\n    }\n};\nconst applyMarkerAttributes = (context, attributes) => {\n    const fillStyle = attributes['color'] ?? 'black';\n    if (typeof fillStyle === 'string') {\n        context.fillStyle = fillStyle;\n    }\n};\nfunction sleepMsec(msec) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, msec);\n    });\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n// BEGIN drawAnnotation\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n// let drawAnnotationDrawCode = 0\n// const drawAnnotation = async (o: {\n//     canvasContext: CanvasRenderingContext2D\n//     canvasWidth: number\n//     canvasHeight: number\n//     visibleStartTimeSec: number\n//     visibleEndTimeSec: number\n//     margins: {left: number, right: number, top: number, bottom: number}\n//     annotation: TimeseriesAnnotationFileData\n// }) => {\n//     drawAnnotationDrawCode += 1\n//     const thisDrawAnnotationDrawCode = drawAnnotationDrawCode\n//     const {canvasContext, canvasWidth, canvasHeight, visibleStartTimeSec, visibleEndTimeSec, margins, annotation} = o\n//     const {events, event_types} = annotation\n//     const eventsFiltered = events.filter(e => (e.s <= visibleEndTimeSec) && (e.e >= visibleStartTimeSec))\n//     const colors = [\n//         [255, 0, 0],\n//         [0, 255, 0],\n//         [0, 0, 255],\n//         [255, 255, 0],\n//         [255, 0, 255],\n//         [0, 255, 255],\n//         [255, 128, 0],\n//         [255, 0, 128],\n//         [128, 255, 0],\n//         [0, 255, 128],\n//         [128, 0, 255],\n//         [0, 128, 255]\n//     ] as [number, number, number][]\n//     const colorsForEventTypes: {[key: string]: [number, number, number]} = {}\n//     for (const et of event_types) {\n//         const color = colors[et.color_index % colors.length]\n//         colorsForEventTypes[et.event_type] = color\n//     }\n//     let timer = Date.now()\n//     for (const pass of ['rect', 'line']) {\n//         for (const e of eventsFiltered) {\n//             if (thisDrawAnnotationDrawCode !== drawAnnotationDrawCode) return\n//             const color = colorsForEventTypes[e.t]\n//             if (e.e > e.s) {\n//                 if (pass !== 'rect') continue\n//                 const R = {\n//                     x: margins.left + (e.s - visibleStartTimeSec) / (visibleEndTimeSec - visibleStartTimeSec) * (canvasWidth - margins.left - margins.right),\n//                     y: margins.top,\n//                     w: (e.e - e.s) / (visibleEndTimeSec - visibleStartTimeSec) * (canvasWidth - margins.left - margins.right),\n//                     h: canvasHeight - margins.top - margins.bottom\n//                 }\n//                 canvasContext.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},0.3)`\n//                 canvasContext.fillRect(R.x, R.y, R.w, R.h)\n//                 const elapsed = Date.now() - timer\n//                 if (elapsed > 100) {\n//                     await sleepMsec(elapsed)\n//                     timer = Date.now()\n//                 }\n//             }\n//             else {\n//                 if (pass !== 'line') continue\n//                 const pt1 = {\n//                     x: margins.left + (e.s - visibleStartTimeSec) / (visibleEndTimeSec - visibleStartTimeSec) * (canvasWidth - margins.left - margins.right),\n//                     y: margins.top\n//                 }\n//                 const pt2 = {\n//                     x: pt1.x,\n//                     y: canvasHeight - margins.bottom\n//                 }\n//                 canvasContext.strokeStyle = `rgba(${color[0]},${color[1]},${color[2]},1)`\n//                 canvasContext.beginPath()\n//                 canvasContext.moveTo(pt1.x, pt1.y)\n//                 canvasContext.lineTo(pt2.x, pt2.y)\n//                 canvasContext.stroke()\n//             }\n//         }\n//     }\n//     function sleepMsec(msec: number) {\n//         return new Promise((resolve) => {\n//             setTimeout(resolve, msec)\n//         })\n//     }\n// }\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n// END drawAnnotation\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n// export { }\n";
export default _default;
